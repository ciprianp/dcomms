using System;
using System.IO;
using System.Text;

namespace Dcomms.P2PTP
{
    public static class P2ptpCommon
    {
        public const ushort ProtocolVersion = 1;

        static bool DecodeValidSignature(byte[] data)
        {
            var s = PacketHeaders.P2PTP;
            return data.Length >= HeaderSize &&
                data[0] == s[0] && data[1] == s[1] && data[2] == s[2] && data[3] == s[3];
        }
        public static PacketTypes? DecodeHeader(byte[] data)
        {
            if (!DecodeValidSignature(data)) return null;
            return (PacketTypes)data[4];
        }
        public const int HeaderSize = 5;
        public static void EncodeHeader(byte[] data, PacketTypes packetType)
        {
            var s = PacketHeaders.P2PTP;
            data[0] = s[0];
            data[1] = s[1];
            data[2] = s[2];
            data[3] = s[3];
            data[4] = (byte)packetType;
        }
        public static void EncodeHeader(BinaryWriter writer, PacketTypes packetType)
        {
            writer.Write(PacketHeaders.P2PTP);
            writer.Write((byte)packetType);
        }
        
        static readonly DateTime BaseDate = new DateTime(2019, 1, 1);
        static readonly DateTime MaxDate = BaseDate.AddSeconds(Math.Pow(2, 32));
        internal static uint ToUInt32(this DateTime date)
        {
            if (date < BaseDate) throw new ArgumentException();
            if (date >= MaxDate) throw new ArgumentException();
            return (uint)((date - BaseDate).TotalSeconds);
        }
        internal static DateTime FromUInt32(this uint v)
        {
            return BaseDate.AddSeconds(v);
        }

    }

    /// <summary>
    /// contains unique, known headers, i.e. first bytes in UDP packets
    /// </summary>
    public static class PacketHeaders
    {
        public static readonly byte[] P2PTP = new byte[] { 154, 77, 200, 11 };
        /// <summary>
        /// main UDP payload, used by SUBT extension
        /// </summary>
        public static readonly byte[] SubtPayload = new byte[] { 104, 78 };

    }

   
    public class PeerId
    {
        public string GuidString => Guid.ToString();
        public readonly Guid Guid;
        public PeerId(Guid guid)
        {
            if (guid.Equals(Guid.Empty)) throw new ArgumentException(nameof(guid));
            Guid = guid;
        }
        public override string ToString()
        {
            return $"{Guid}";
        }
        public override bool Equals(object obj)
        {
            var obj2 = (PeerId)obj;
            return obj2.Guid.Equals(this.Guid);
        }
        public override int GetHashCode()
        {
            return Guid.GetHashCode();
        }

        public const int EncodedSize = 16;
        public static void Encode(PeerId testNodeId, byte[] data, ref int index)
        {
            var guidBytes = (testNodeId?.Guid ?? Guid.Empty).ToByteArray();
            Array.Copy(guidBytes, 0, data, index, EncodedSize);
            index += EncodedSize;
        }
        public static void Encode(BinaryWriter writer, PeerId testNodeId)
        {
            var guidBytes = (testNodeId?.Guid ?? Guid.Empty).ToByteArray();
            writer.Write(guidBytes);
        }
        public static PeerId Decode(byte[] data, ref int index)
        {
            var guidBytes = new byte[EncodedSize];
            Array.Copy(data, index, guidBytes, 0, EncodedSize);
            index += EncodedSize;
            var guid = new Guid(guidBytes);
            if (guid.Equals(Guid.Empty)) return null;
            else return new PeerId(guid);
        }
        public static PeerId Decode(BinaryReader reader)
        {
            var guidBytes = reader.ReadBytes(EncodedSize);
            var guid = new Guid(guidBytes);
            if (guid.Equals(Guid.Empty)) return null;
            else return new PeerId(guid);
        }
    }

    /// <summary>
    /// is generated by peer that initially sends 'setup'
    /// uniquely identifies the stream (connection to another peer) within local peer, and all connected peers
    /// is used by SUBT extension to quickly find corresponding stream, within receiver thread
    /// </summary>
    public class StreamId
    {
        public readonly uint Id;
        public StreamId(uint id)
        {
            if (id == 0) throw new ArgumentException(nameof(id));
            Id = id;
        }
        public override string ToString()
        {
            return $"{Id}";
        }
        public override bool Equals(object obj)
        {
            // for dictionary of remote peers: dates are not included, as they are dynamic

            var obj2 = (StreamId)obj;
            return obj2.Id == this.Id;
        }
        public override int GetHashCode()
        {
            return Id.GetHashCode();
        }

        public const int EncodedSize = 4;
        public static void Encode(StreamId streamId, byte[] data, ref int index)
        {
            PacketProcedures.EncodeUInt32(data, ref index, streamId?.Id ?? 0);
        }
        public static void Encode(BinaryWriter writer, StreamId streamId)
        {
            PacketProcedures.EncodeUInt32(writer, streamId?.Id ?? 0);
        }
        public static StreamId Decode(byte[] data, ref int index)
        {
            var id = PacketProcedures.DecodeUInt32(data, ref index);
            if (id == 0) return null;
            else return new StreamId(id);
        }
        public static StreamId Decode(BinaryReader reader)
        {
            var id = PacketProcedures.DecodeUInt32(reader);
            if (id == 0) return null;
            else return new StreamId(id);
        }
    }

}
